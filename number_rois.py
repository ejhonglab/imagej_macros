
from pprint import pprint

from ij import IJ
from ij.gui import Roi
from ij.plugin.frame import RoiManager


verbose = False

def is_roi_name_ij_generated(manager, roi_name):
    """Returns whether the name for this ROI was autogenerated by ImageJ

    For names where this is True, they should look like nnnn-nnnn-nnnn
    """
    # TODO may want to use re instead, and check what i was matching for in my ijroi
    # fork before.
    if manager.getSliceNumber(roi_name) == -1:
        return False

    err_msg = 'roi name ' + roi_name + ' in unexpected format'

    # TODO i thought there were formats w/ diff number of '-' separted parts, but i
    # tried on one each of my projection vs time-including TIFFs, and both had three
    # parts... (again, see my old implementation handling this in ijroi fork)
    parts = roi_name.split('-')
    assert len(parts) == 3, err_msg
    for p in parts:
        # This should successed for all (though there may be leading zeros)
        try:
            int(p)
        except ValueError:
            raise AssertionError(err_msg)

    return True


def main():
    manager = RoiManager.getInstance()
    if not manager:
        if verbose:
            print 'ROI manager not open. doing nothing.'
        return

    rois = manager.getRoisAsArray()

    generated = []
    # Things already numbered, whether manually or via this plugin.
    numbered = []
    # Things with arbitrary strings names not either parseable to ints / ImageJ default
    # name format.
    manual = []

    # TODO also sort on x,y coords?
    # TODO option to not change existing numbers (so notes about them can remain true)?

    generated_indices = []
    # For determining what already shares numbers, so we can preserve that.
    old2new_num = dict()
    next_num = 0
    for roi in sorted(rois, key=lambda r: r.getZPosition()):

        i = manager.getRoiIndex(roi)
        assert i != -1, 'roi index not found'

        name = roi.getName()
        if is_roi_name_ij_generated(manager, name):
            generated.append(name)
            manager.rename(i, str(next_num))
            next_num += 1

        try:
            n = int(name)
            if n not in old2new_num:
                new_num = next_num
                old2new_num[n] = new_num
                next_num += 1
            else:
                new_num = old2new_num[n]

            manager.rename(i, str(new_num))
            numbered.append(name)

        except ValueError:
            manual.append(name)

    if verbose:
        print '\ngenerated:'
        pprint(generated)
        print '\nnumbered:'
        pprint(numbered)
        print '\nmanual:'
        pprint(manual)
        print ''


if __name__ == '__main__':
    main()

